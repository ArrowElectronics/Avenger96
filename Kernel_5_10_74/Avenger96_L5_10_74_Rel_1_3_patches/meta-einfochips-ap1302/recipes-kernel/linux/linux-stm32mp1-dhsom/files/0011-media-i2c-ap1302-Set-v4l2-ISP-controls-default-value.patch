From 3b63271c8b2b9a1d06357ee9eb915487053fe84b Mon Sep 17 00:00:00 2001
From: Anil Dsouza <anil.dsouza@einfochips.com>
Date: Thu, 3 Mar 2022 16:13:22 +0530
Subject: [PATCH] media: i2c: ap1302: Set v4l2 ISP controls default value from
 AP1302

* During boot up read ISP control register values related to v4l2
  control and set it as default value in v4l2 layer from ap1302 driver
* Return type of sysfs entry for writing AP1302 register is corrected

Change-Id: Ic2885639f70208b809abdb3b2f6a11feb163043a
Signed-off-by: Anil Dsouza <anil.dsouza@einfochips.com>
---
 drivers/media/i2c/ap1302.c | 122 +++++++++++++++++++++++++++++++------
 1 file changed, 104 insertions(+), 18 deletions(-)

diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
index 200d8b762..8e681b2d8 100644
--- a/drivers/media/i2c/ap1302.c
+++ b/drivers/media/i2c/ap1302.c
@@ -369,6 +369,9 @@
 #define AP1302_TCLK_PRE_MASK			0xFF00
 #define AP1302_TCLK_PRE_SHIFT			0x8
 
+#define AP1302_V4L2_CTRLS			7
+#define AWB_MODE_0				0x00000000
+#define AWB_MODE_1				0x00000001
 struct ap1302_device;
 
 enum {
@@ -478,6 +481,16 @@ struct ap1302_firmware_header {
 	u32 dummy;
 } __packed;
 
+enum ap1302_v4l2_ctrls {
+	AP1302_CTRL_WB = 0,
+	AP1302_CTRL_GAMMA,
+	AP1302_CTRL_CONTRAST,
+	AP1302_CTRL_BRIGHTNESS,
+	AP1302_CTRL_SATURATION,
+	AP1302_CTRL_EXPOSURE,
+	AP1302_CTRL_GAIN
+};
+
 #define MAX_FW_LOAD_RETRIES 3
 
 static const struct ap1302_format_info supported_video_formats[] = {
@@ -1015,7 +1028,7 @@ static int ap1302_reg_data_set(void *arg, u64 val)
 		goto unlock;
 	}
 
-	ap1302_write(ap1302, addr, val, &ret);
+	ret = ap1302_write(ap1302, addr, val, NULL);
 
 unlock:
 	mutex_unlock(&ap1302->debugfs.lock);
@@ -1467,7 +1480,7 @@ static const struct v4l2_ctrl_ops ap1302_ctrl_ops = {
 	.s_ctrl = ap1302_s_ctrl,
 };
 
-static const struct v4l2_ctrl_config ap1302_ctrls[] = {
+static struct v4l2_ctrl_config ap1302_ctrls[] = {
 	{
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
@@ -1479,37 +1492,33 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 		.id = V4L2_CID_GAMMA,
 		.name = "Gamma",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x1000,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_CONTRAST,
 		.name = "Contrast",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_BRIGHTNESS,
 		.name = "Brightness",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_SATURATION,
 		.name = "Saturation",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x1000,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_EXPOSURE,
@@ -1518,16 +1527,14 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 		.min = 0x0,
 		.max = 0xC,
 		.step = 1,
-		.def = 0xC,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_GAIN,
 		.name = "Gain",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_LINK_FREQ,
@@ -1537,11 +1544,90 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 	},
 };
 
+/*
+ * ap1302_get_ctrls() - reads the v4l2 control related register values from
+ *                      AP1302
+ *
+ * During boot up the ISP control parameter in the v4l2layer should have value
+ * displayed based on the value available in the corresponding AP1302 register.
+ * This function reads the ISP controls related register values and set them
+ * default value in the v4l2 layer.
+ */
+
+static int ap1302_get_ctrls(struct ap1302_device *ap1302)
+{
+	int ret = 0;
+	u32 val = 0x00000000;
+
+	/* get the CONTRAST value form AP1302 */
+	ret = ap1302_read(ap1302, AP1302_CONTRAST, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_CONTRAST].def = val;
+
+	/* get the BRIGHTNESS value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_BRIGHTNESS, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_BRIGHTNESS].def = val;
+
+	/* get the SATURATION value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_SATURATION, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_SATURATION].def = val;
+
+	/* get the GAMMA value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_GAMMA, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_GAMMA].def = val;
+
+	/* get the GAIN value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_AE_MANUAL_GAIN, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_GAIN].def = val;
+
+	/* get the EXPOSURE value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_AE_CTRL, &val);
+	if (ret < 0)
+		return ret;
+	val = val & AP1302_AE_CTRL_MODE_MASK;
+	ap1302_ctrls[AP1302_CTRL_EXPOSURE].def = val;
+
+	/* get the WHITE BALANCE value form AP1302 */
+	val = 0x00000000;
+	ret = ap1302_read(ap1302, AP1302_AWB_CTRL, &val);
+	if (ret < 0)
+		return ret;
+
+	val &= AP1302_AWB_CTRL_MODE_MASK;
+	val = (val != AP1302_AWB_CTRL_MODE_AUTO) ? AWB_MODE_0 : AWB_MODE_1;
+	ap1302_ctrls[AP1302_CTRL_WB].def = val;
+
+	return ret;
+}
+
 static int ap1302_ctrls_init(struct ap1302_device *ap1302)
 {
 	unsigned int i;
 	int ret;
 
+	ret = ap1302_get_ctrls(ap1302);
+	if (ret)
+		return ret;
+
 	ret = v4l2_ctrl_handler_init(&ap1302->ctrls, ARRAY_SIZE(ap1302_ctrls));
 	if (ret)
 		return ret;
-- 
2.17.1

