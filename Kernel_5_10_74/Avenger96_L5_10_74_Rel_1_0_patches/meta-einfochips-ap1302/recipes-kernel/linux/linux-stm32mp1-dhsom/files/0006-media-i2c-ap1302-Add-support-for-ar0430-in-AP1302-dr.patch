From fa8de3ab23422d73e32b9119eacfcbe71746a398 Mon Sep 17 00:00:00 2001
From: Anil Dsouza <anil.dsouza@einfochips.com>
Date: Mon, 10 Jan 2022 14:09:26 +0530
Subject: [PATCH 2/5] media:i2c: ap1302: Add support for ar0430 in AP1302
 driver

This patch adds support for AR0430 in AP1302. This patch also updates
the clock settings of AP1302. STM32MP1 DCMI can work theoretically at
1600Mbps data rate but it is hardly achievable on a parallel port interface
due to I/O slew rate pin constraints on DCMI. Hence set host interface MIPI
data rate as 333Mbps.

Change-Id: Id4b7c5cc4026f91212b76863cbd9231a542133f5
Signed-off-by: Anil Dsouza <anil.dsouza@einfochips.com>
---
 drivers/media/i2c/ap1302.c | 566 +++++++++++++++++++++----------------
 1 file changed, 322 insertions(+), 244 deletions(-)

diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
index 96da195c6..215adadf5 100644
--- a/drivers/media/i2c/ap1302.c
+++ b/drivers/media/i2c/ap1302.c
@@ -34,7 +34,7 @@
 #define AP1302_MIN_WIDTH			24U
 #define AP1302_MIN_HEIGHT			16U
 #define AP1302_MAX_WIDTH			4224U
-#define AP1302_MAX_HEIGHT			4092U
+#define AP1302_MAX_HEIGHT			3156U
 
 #define AP1302_REG_16BIT(n)			((2 << 24) | (n))
 #define AP1302_REG_32BIT(n)			((4 << 24) | (n))
@@ -110,6 +110,7 @@
 #define AP1302_PREVIEW_ROI_X1			AP1302_REG_16BIT(0x2008)
 #define AP1302_PREVIEW_ROI_Y1			AP1302_REG_16BIT(0x200a)
 #define AP1302_PREVIEW_OUT_FMT			AP1302_REG_16BIT(0x2012)
+#define AP1302_PREVIEW_MAX_FPS			AP1302_REG_16BIT(0x2020)
 #define AP1302_PREVIEW_OUT_FMT_IPIPE_BYPASS	BIT(13)
 #define AP1302_PREVIEW_OUT_FMT_SS		BIT(12)
 #define AP1302_PREVIEW_OUT_FMT_FAKE_EN		BIT(11)
@@ -165,6 +166,19 @@
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_MODE	BIT(3)
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(n)	((n) << 0)
 
+#define AP1302_SYSTEM_FREQ_IN           AP1302_REG_32BIT(0x6024)
+#define AP1302_PLL_0_DIV                AP1302_REG_32BIT(0x602C)
+#define AP1302_PLL_1_DIV                AP1302_REG_32BIT(0x6038)
+#define AP1302_PREVIEW_DIV_CPU          AP1302_REG_32BIT(0x2050)
+#define AP1302_PREVIEW_DIV_IPIPE        AP1302_REG_32BIT(0x2054)
+#define AP1302_PREVIEW_DIV_SINF         AP1302_REG_32BIT(0x2058)
+#define AP1302_PREVIEW_DIV_HINF         AP1302_REG_32BIT(0x205C)
+#define AP1302_PREVIEW_DIV_HINF_MIPI    AP1302_REG_32BIT(0x2064)
+#define AP1302_PREVIEW_DIV_IP           AP1302_REG_32BIT(0x2068)
+#define AP1302_PREVIEW_DIV_SPI          AP1302_REG_32BIT(0x206C)
+#define AP1302_PREVIEW_DIV_PRI_SENSOR   AP1302_REG_32BIT(0x2070)
+#define AP1302_PREVIEW_DIV_SEC_SENSOR   AP1302_REG_32BIT(0x2074)
+
 /* IQ Registers */
 #define AP1302_AE_CTRL			AP1302_REG_16BIT(0x5002)
 #define AP1302_AE_CTRL_STATS_SEL		BIT(11)
@@ -301,6 +315,7 @@
 #define AP1302_REG_ADV_START			0xe000
 #define AP1302_ADVANCED_BASE			AP1302_REG_32BIT(0xf038)
 #define AP1302_SIP_CRC				AP1302_REG_16BIT(0xf052)
+#define AP1302_BOOTDATA_CHECKSUM		AP1302_REG_16BIT(0x6134)
 
 /* Advanced System Registers */
 #define AP1302_ADV_IRQ_SYS_INTE			AP1302_REG_32BIT(0x00230000)
@@ -358,8 +373,6 @@
 struct ap1302_device;
 
 enum {
-	AP1302_PAD_SINK_0,
-	AP1302_PAD_SINK_1,
 	AP1302_PAD_SOURCE,
 	AP1302_PAD_MAX,
 };
@@ -389,6 +402,7 @@ struct ap1302_sensor_info {
 	const char *name;
 	unsigned int i2c_addr;
 	struct ap1302_size resolution;
+	u16 fps;
 	u32 format;
 	const struct ap1302_sensor_supply *supplies;
 };
@@ -406,6 +420,10 @@ struct ap1302_sensor {
 	struct media_pad pad;
 };
 
+static const s64 link_freq_menu_items[] = {
+	160000000,
+};
+
 static inline struct ap1302_sensor *to_ap1302_sensor(struct v4l2_subdev *sd)
 {
 	return container_of(sd, struct ap1302_sensor, sd);
@@ -417,6 +435,8 @@ struct ap1302_device {
 
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *standby_gpio;
+	struct gpio_desc *i2csel_gpio;
+	struct gpio_desc *isptrig_gpio;
 	struct clk *clock;
 	struct regmap *regmap16;
 	struct regmap *regmap32;
@@ -433,7 +453,7 @@ struct ap1302_device {
 	struct ap1302_format formats[AP1302_PAD_MAX];
 	unsigned int width_factor;
 	bool streaming;
-
+	struct v4l2_fract frame_interval;
 	struct v4l2_ctrl_handler ctrls;
 
 	const struct ap1302_sensor_info *sensor_info;
@@ -443,6 +463,7 @@ struct ap1302_device {
 		struct dentry *dir;
 		struct mutex lock;
 		u32 sipm_addr;
+		u32 reg_addr;
 	} debugfs;
 };
 
@@ -452,25 +473,19 @@ static inline struct ap1302_device *to_ap1302(struct v4l2_subdev *sd)
 }
 
 struct ap1302_firmware_header {
-	u16 pll_init_size;
-	u16 crc;
+	u32 checksum;
+	u32 pll_init_size;
+	u32 firmware_size;
+	u32 dummy;
 } __packed;
 
 #define MAX_FW_LOAD_RETRIES 3
 
 static const struct ap1302_format_info supported_video_formats[] = {
 	{
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.code = MEDIA_BUS_FMT_UYVY8_2X8,
 		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
 			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_422,
-	}, {
-		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
-	}, {
-		.code = MEDIA_BUS_FMT_VYYUYY8_1X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
 	},
 };
 
@@ -516,7 +531,21 @@ static const struct ap1302_sensor_info ap1302_sensor_info[] = {
 			{ "vdd", 0 },
 			{ NULL, 0 },
 		},
-	},
+	}, {
+		.model = "onnn,ar0430",
+		.name = "ar0430",
+		.i2c_addr = 0x36,
+		.resolution = { 2316, 1746},
+		.fps = 3,
+		.format = MEDIA_BUS_FMT_UYVY8_2X8,
+		.supplies = (const struct ap1302_sensor_supply[]) {
+			{ "vddpll", 0 },
+			{ "vaa", 0 },
+			{ "vdd", 0 },
+			{ "vddio", 0 },
+			{ NULL, 0 },
+		},
+	}
 };
 
 static const struct ap1302_sensor_info ap1302_sensor_info_tpg = {
@@ -883,6 +912,94 @@ static int ap1302_sipm_data_set(void *arg, u64 val)
 	return ret;
 }
 
+/*
+ * These sysfs debug functions are used to read the AP1302 register values
+ * Usage : 1. Write Address
+ *            echo 0xY00ZZZZ > /sys/kernel/debug/ap1302.X-00XX/reg_addr
+ *            Y - Type of register - 2 for 16bit, 4 for 32-bit
+ *            ZZZZ - Register address
+ *         2. Read Data
+ *            cat /sys/kernel/debug/ap1302.X-00XX/reg_data
+ */
+static int ap1302_reg_addr_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	*val = ap1302->debugfs.reg_addr;
+	mutex_unlock(&ap1302->debugfs.lock);
+	return 0;
+}
+
+static int ap1302_reg_addr_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	if (val & ~0x700ffff)
+		return -EINVAL;
+
+	switch ((val >> 24) & 7) {
+	case 1:
+	case 2:
+	case 4:
+	break;
+	default:
+	return -EINVAL;
+	}
+	mutex_lock(&ap1302->debugfs.lock);
+	ap1302->debugfs.reg_addr = val;
+	mutex_unlock(&ap1302->debugfs.lock);
+	return 0;
+}
+
+static int ap1302_reg_data_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ret = ap1302_read(ap1302, addr,
+			  &value);
+	if (!ret)
+		*val = value;
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_reg_data_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ap1302_write(ap1302, addr, val, &ret);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
 static int ap1302_mipi_tclk_post_get(void *arg, u64 *val)
 {
 	struct ap1302_device *ap1302 = arg;
@@ -979,6 +1096,11 @@ DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_addr_fops, ap1302_sipm_addr_get,
 			 ap1302_sipm_addr_set, "0x%08llx\n");
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_data_fops, ap1302_sipm_data_get,
 			 ap1302_sipm_data_set, "0x%08llx\n");
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_addr_fops, ap1302_reg_addr_get,
+			 ap1302_reg_addr_set, "0x%08llx\n");
+
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_data_fops, ap1302_reg_data_get,
+			 ap1302_reg_data_set, "0x%08llx\n");
 
 /* The debugfs is to read and write mipi clk parameters tclk_post values */
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_mipi_tclk_post_fops, ap1302_mipi_tclk_post_get,
@@ -1007,6 +1129,10 @@ static void ap1302_debugfs_init(struct ap1302_device *ap1302)
 				   ap1302, &ap1302_sipm_addr_fops);
 	debugfs_create_file_unsafe("sipm_data", 0600, ap1302->debugfs.dir,
 				   ap1302, &ap1302_sipm_data_fops);
+	debugfs_create_file_unsafe("reg_addr", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_addr_fops);
+	debugfs_create_file_unsafe("reg_data", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_data_fops);
 	debugfs_create_file_unsafe("mipi_tclk_post", 0600, ap1302->debugfs.dir,
 				   ap1302, &ap1302_mipi_tclk_post_fops);
 	debugfs_create_file_unsafe("mipi_tclk_pre", 0600, ap1302->debugfs.dir,
@@ -1023,68 +1149,6 @@ static void ap1302_debugfs_cleanup(struct ap1302_device *ap1302)
  * Power Handling
  */
 
-static int ap1302_power_on_sensors(struct ap1302_device *ap1302)
-{
-	struct ap1302_sensor *sensor;
-	unsigned int i, j;
-	int ret;
-
-	if (!ap1302->sensor_info->supplies)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		sensor = &ap1302->sensors[i];
-		ret = 0;
-
-		for (j = 0; j < sensor->num_supplies; ++j) {
-			unsigned int delay;
-
-			/*
-			 * We can't use regulator_bulk_enable() as it would
-			 * enable all supplies in parallel, breaking the sensor
-			 * power sequencing constraints.
-			 */
-			ret = regulator_enable(sensor->supplies[j].consumer);
-			if (ret < 0) {
-				dev_err(ap1302->dev,
-					"Failed to enable supply %u for sensor %u\n",
-					j, i);
-				goto error;
-			}
-
-			delay = ap1302->sensor_info->supplies[j].post_delay_us;
-			usleep_range(delay, delay + 100);
-		}
-	}
-
-	return 0;
-
-error:
-	for (; j > 0; --j)
-		regulator_disable(sensor->supplies[j - 1].consumer);
-
-	for (; i > 0; --i) {
-		sensor = &ap1302->sensors[i - 1];
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-
-	return ret;
-}
-
-static void ap1302_power_off_sensors(struct ap1302_device *ap1302)
-{
-	unsigned int i;
-
-	if (!ap1302->sensor_info->supplies)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-}
-
 static int ap1302_power_on(struct ap1302_device *ap1302)
 {
 	int ret;
@@ -1193,6 +1257,7 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 {
 	const struct ap1302_format *format = &ap1302->formats[AP1302_PAD_SOURCE];
 	unsigned int data_lanes = ap1302->bus_cfg.bus.mipi_csi2.num_data_lanes;
+	const struct ap1302_sensor_info *info = ap1302->sensor_info;
 	int ret = 0;
 
 	ap1302_write(ap1302, AP1302_PREVIEW_HINF_CTRL,
@@ -1205,6 +1270,8 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 		     format->format.height, &ret);
 	ap1302_write(ap1302, AP1302_PREVIEW_OUT_FMT,
 		     format->info->out_fmt, &ret);
+
+	ap1302_write(ap1302, AP1302_PREVIEW_MAX_FPS, (info->fps << 8), &ret);
 	if (ret < 0)
 		return ret;
 
@@ -1426,7 +1493,6 @@ static int ap1302_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ap1302_device *ap1302 =
 		container_of(ctrl->handler, struct ap1302_device, ctrls);
-
 	switch (ctrl->id) {
 	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
 		return ap1302_set_wb_mode(ap1302, ctrl->val);
@@ -1464,6 +1530,9 @@ static int ap1302_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_POWER_LINE_FREQUENCY:
 		return ap1302_set_flicker_freq(ap1302, ctrl->val);
 
+	case V4L2_CID_LINK_FREQ:
+		return 0;
+
 	default:
 		return -EINVAL;
 	}
@@ -1570,6 +1639,12 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 		.min = 0,
 		.max = 3,
 		.def = 3,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.max = 0,
+		.def = 0,
+		.qmenu_int = link_freq_menu_items,
 	},
 };
 
@@ -1686,45 +1761,50 @@ static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_sensor_info *info = ap1302->sensor_info;
 	unsigned int i;
 
 	if (fse->index)
 		return -EINVAL;
 
-	if (fse->pad != AP1302_PAD_SOURCE) {
-		/*
-		 * On the sink pads, only the size produced by the sensor is
-		 * supported.
-		 */
-		if (fse->code != ap1302->sensor_info->format)
-			return -EINVAL;
-
-		fse->min_width = ap1302->sensor_info->resolution.width;
-		fse->min_height = ap1302->sensor_info->resolution.height;
-		fse->max_width = ap1302->sensor_info->resolution.width;
-		fse->max_height = ap1302->sensor_info->resolution.height;
-	} else {
-		/*
-		 * On the source pad, the AP1302 can freely scale within the
-		 * scaler's limits.
-		 */
-		for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
-			if (supported_video_formats[i].code == fse->code)
-				break;
-		}
+	/*
+	 * On the source pad, the AP1302 can freely scale within the
+	 * scaler's limits.
+	 */
+	for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
+		if (supported_video_formats[i].code == fse->code)
+			break;
+	}
 
-		if (i >= ARRAY_SIZE(supported_video_formats))
-			return -EINVAL;
+	if (i >= ARRAY_SIZE(supported_video_formats))
+		return -EINVAL;
 
-		fse->min_width = AP1302_MIN_WIDTH * ap1302->width_factor;
-		fse->min_height = AP1302_MIN_HEIGHT;
-		fse->max_width = AP1302_MAX_WIDTH;
-		fse->max_height = AP1302_MAX_HEIGHT;
-	}
+	fse->max_width = info->resolution.width;
+	fse->min_width = info->resolution.width;
+	fse->max_height = info->resolution.height;
+	fse->min_height = info->resolution.height;
 
 	return 0;
 }
 
+static int ap1302_enum_frame_interval(
+    struct v4l2_subdev *sd,
+    struct v4l2_subdev_pad_config *cfg,
+    struct v4l2_subdev_frame_interval_enum *fie)
+{
+    struct ap1302_device *ap1302 = to_ap1302(sd);
+    const struct ap1302_sensor_info *info = ap1302->sensor_info;
+    if (fie->pad != 0)
+	    return -EINVAL;
+    if (fie->index)
+	    return -EINVAL;
+
+    fie->interval.numerator = 1;
+    fie->interval.denominator = info->fps;
+    return 0;
+};
+
+
 static int ap1302_get_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
 			  struct v4l2_subdev_format *fmt)
@@ -2137,6 +2217,7 @@ static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
 	.init_cfg = ap1302_init_cfg,
 	.enum_mbus_code = ap1302_enum_mbus_code,
 	.enum_frame_size = ap1302_enum_frame_size,
+	.enum_frame_interval = ap1302_enum_frame_interval,
 	.get_fmt = ap1302_get_fmt,
 	.set_fmt = ap1302_set_fmt,
 	.get_selection = ap1302_get_selection,
@@ -2262,98 +2343,6 @@ static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
 	return 0;
 }
 
-static void ap1302_sensor_dev_release(struct device *dev)
-{
-	of_node_put(dev->of_node);
-	kfree(dev);
-}
-
-static int ap1302_sensor_init(struct ap1302_sensor *sensor, unsigned int index)
-{
-	struct ap1302_device *ap1302 = sensor->ap1302;
-	struct v4l2_subdev *sd = &sensor->sd;
-	unsigned int i;
-	int ret;
-
-	sensor->index = index;
-
-	/*
-	 * Register a device for the sensor, to support usage of the regulator
-	 * API.
-	 */
-	sensor->dev = kzalloc(sizeof(*sensor->dev), GFP_KERNEL);
-	if (!sensor->dev)
-		return -ENOMEM;
-
-	sensor->dev->parent = ap1302->dev;
-	sensor->dev->of_node = of_node_get(sensor->of_node);
-	sensor->dev->release = &ap1302_sensor_dev_release;
-	dev_set_name(sensor->dev, "%s-%s.%u", dev_name(ap1302->dev),
-		     ap1302->sensor_info->name, index);
-
-	ret = device_register(sensor->dev);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"Failed to register device for sensor %u\n", index);
-		goto error;
-	}
-
-	/* Retrieve the power supplies for the sensor, if any. */
-	if (ap1302->sensor_info->supplies) {
-		const struct ap1302_sensor_supply *supplies =
-			ap1302->sensor_info->supplies;
-		unsigned int num_supplies;
-
-		for (num_supplies = 0; supplies[num_supplies].name; ++num_supplies)
-			;
-
-		sensor->supplies = devm_kcalloc(ap1302->dev, num_supplies,
-						sizeof(*sensor->supplies),
-						GFP_KERNEL);
-		if (!sensor->supplies) {
-			ret = -ENOMEM;
-			goto error;
-		}
-
-		for (i = 0; i < num_supplies; ++i)
-			sensor->supplies[i].supply = supplies[i].name;
-
-		ret = regulator_bulk_get(sensor->dev, num_supplies,
-					 sensor->supplies);
-		if (ret < 0) {
-			dev_err(ap1302->dev,
-				"Failed to get supplies for sensor %u\n", index);
-			goto error;
-		}
-
-		sensor->num_supplies = i;
-	}
-
-	sd->dev = sensor->dev;
-	v4l2_subdev_init(sd, &ap1302_sensor_subdev_ops);
-
-	snprintf(sd->name, sizeof(sd->name), "%s %u",
-		 ap1302->sensor_info->name, index);
-
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
-	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
-
-	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"failed to initialize media entity for sensor %u: %d\n",
-			index, ret);
-		goto error;
-	}
-
-	return 0;
-
-error:
-	put_device(sensor->dev);
-	return ret;
-}
-
 static void ap1302_sensor_cleanup(struct ap1302_sensor *sensor)
 {
 	media_entity_cleanup(&sensor->sd.entity);
@@ -2463,6 +2452,65 @@ static int ap1302_write_fw_window(struct ap1302_device *ap1302, const u8 *buf,
 
 	return 0;
 }
+/*
+ * This function is to set MIPI Clock to get desired data rate
+ * Eg:	For Data Rate 320 Mbps
+ *	fclk_in = 48MHz
+ *	ref_div = 1
+ *	fpll_ref_clk = fclk_in/(ref_div +1) = 24MHz
+ *	fb_div = 20
+ *	fpll_vco_clk = fpll_ref_clk*fb_div*2 = 960 MHz
+ *	out_div = 0
+ *	fpll_clk = fpll_vco_clk/(out_div+1) = 960 MHz
+ *	DIV_HINF_MIPI = 3
+ *	DIV_HINF = 5.5
+ *	HINF_MIPI_FREQ = fpll_clk / DIV_HINF_MIPI = 320 Mbps
+ *	HINF_FREQ = fpll_clk / DIV_HINF = 174.3574 MHz
+ */
+
+static int ap1302_init_pll(struct ap1302_device *ap1302)
+{
+	int ret;
+
+	ret = ap1302_write(ap1302,AP1302_SYSTEM_FREQ_IN,0x300000, NULL);
+	if (ret)
+		return ret;
+	ret = ap1302_write(ap1302,AP1302_PLL_0_DIV,0x1A0100,NULL);
+	if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PLL_1_DIV,0x140100,NULL);
+	if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_CPU,0x010008,NULL);
+	if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_IPIPE,0x010009,NULL);
+	if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_SINF,0x030002,NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_HINF,0x030009,NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_HINF_MIPI,0x030004,NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_IP,0x010009,NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_SPI,0x00003E,NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_PRI_SENSOR,0x010026, NULL);
+        if (ret)
+                return ret;
+	ret = ap1302_write(ap1302,AP1302_PREVIEW_DIV_SEC_SENSOR,0x0100FF,NULL);
+        if (ret)
+                return ret;
+
+	return 0;
+}
 
 static int ap1302_load_firmware(struct ap1302_device *ap1302)
 {
@@ -2470,18 +2518,13 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	unsigned int fw_size;
 	const u8 *fw_data;
 	unsigned int win_pos = 0;
-	unsigned int crc;
+	unsigned int checksum;
 	int ret;
+	int cnt, val;
 
 	fw_hdr = (const struct ap1302_firmware_header *)ap1302->fw->data;
 	fw_data = (u8 *)&fw_hdr[1];
 	fw_size = ap1302->fw->size - sizeof(*fw_hdr);
-
-	/* Clear the CRC register. */
-	ret = ap1302_write(ap1302, AP1302_SIP_CRC, 0xffff, NULL);
-	if (ret)
-		return ret;
-
 	/*
 	 * Load the PLL initialization settings, set the bootdata stage to 2 to
 	 * apply the basic_init_hp settings, and wait 1ms for the PLL to lock.
@@ -2497,6 +2540,17 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 
 	usleep_range(1000, 2000);
 
+	/*
+	 *This is to check if PLL gets locked
+	 */
+	for(cnt=0;!ret && (cnt<10);cnt++){
+		msleep(2);
+		ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+		if ((val & AP1302_SYS_START_PLL_LOCK)){
+			dev_info(ap1302->dev,"PLL locked\n");
+			break;
+		}
+	}
 	/* Load the rest of the bootdata content and verify the CRC. */
 	ret = ap1302_write_fw_window(ap1302, fw_data + fw_hdr->pll_init_size,
 				     fw_size - fw_hdr->pll_init_size, &win_pos);
@@ -2505,16 +2559,23 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 
 	msleep(40);
 
-	ret = ap1302_read(ap1302, AP1302_SIP_CRC, &crc);
+	/* PLL settings are intialized again based on the ISP and sensor configuration */
+	ret = ap1302_init_pll(ap1302);
 	if (ret)
 		return ret;
 
-	if (crc != fw_hdr->crc) {
-		dev_warn(ap1302->dev,
-			 "CRC mismatch: expected 0x%04x, got 0x%04x\n",
-			 fw_hdr->crc, crc);
-		return -EAGAIN;
-	}
+        /*
+	 *This is to check if PLL gets locked with new configurations
+	 */
+        val=0x00;
+        for(cnt=0; !ret && (cnt<10);cnt++){
+                msleep(2);
+                ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+                if ((val & AP1302_SYS_START_PLL_LOCK )) {
+                        dev_info(ap1302->dev,"PLL locked\n");
+                        break;
+                }
+        }
 
 	/*
 	 * Write 0xffff to the bootdata_stage register to indicate to the
@@ -2524,6 +2585,24 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
+	msleep(30);
+	ret = ap1302_read(ap1302, AP1302_BOOTDATA_CHECKSUM, &checksum);
+        if (ret)
+        {
+                dev_err(ap1302->dev,"load firmware - read checksum error\n");
+                return ret;
+        }
+
+        if (checksum != fw_hdr->checksum) {
+                 dev_err(ap1302->dev,
+                          "checksum mismatch: expected 0x%04x, got 0x%04x\n ret = %d",
+                          fw_hdr->checksum, checksum,ret);
+                 return -EAGAIN;
+        }
+        else {
+                 dev_info(ap1302->dev,"checksum matched \n");
+        }
+
 	/* The AP1302 starts outputting frames right after boot, stop it. */
 	ret = ap1302_stall(ap1302, true);
 	if (ret)
@@ -2571,14 +2650,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
-	/*
-	 * Power the sensors first, as the firmware will access them once it
-	 * gets loaded.
-	 */
-	ret = ap1302_power_on_sensors(ap1302);
-	if (ret < 0)
-		goto error_firmware;
-
 	/*
 	 * Load the firmware, retrying in case of CRC errors. The AP1302 is
 	 * reset with a full power cycle between each attempt.
@@ -2586,7 +2657,7 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	for (retries = 0; retries < MAX_FW_LOAD_RETRIES; ++retries) {
 		ret = ap1302_power_on(ap1302);
 		if (ret < 0)
-			goto error_power_sensors;
+			goto error_power;
 
 		ret = ap1302_detect_chip(ap1302);
 		if (ret)
@@ -2606,17 +2677,13 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 		dev_err(ap1302->dev,
 			"Firmware load retries exceeded, aborting\n");
 		ret = -ETIMEDOUT;
-		goto error_power_sensors;
+		goto error_power;
 	}
 
 	return 0;
 
 error_power:
 	ap1302_power_off(ap1302);
-error_power_sensors:
-	ap1302_power_off_sensors(ap1302);
-error_firmware:
-	release_firmware(ap1302->fw);
 
 	return ret;
 }
@@ -2624,7 +2691,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 static void ap1302_hw_cleanup(struct ap1302_device *ap1302)
 {
 	ap1302_power_off(ap1302);
-	ap1302_power_off_sensors(ap1302);
 }
 
 /* -----------------------------------------------------------------------------
@@ -2648,13 +2714,11 @@ static int ap1302_config_v4l2(struct ap1302_device *ap1302)
 
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 	sd->internal_ops = &ap1302_subdev_internal_ops;
-	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_ISP;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
 	sd->entity.ops = &ap1302_media_ops;
 
 	for (i = 0; i < ARRAY_SIZE(ap1302->pads); ++i)
-		ap1302->pads[i].flags = i == AP1302_PAD_SOURCE
-				      ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
-
+	ap1302->pads[i].flags = MEDIA_PAD_FL_SOURCE;
 	ret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(ap1302->pads),
 				     ap1302->pads);
 	if (ret < 0) {
@@ -2722,6 +2786,27 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 			PTR_ERR(ap1302->standby_gpio));
 		return PTR_ERR(ap1302->standby_gpio);
 	}
+	/* request optional I2C address select pin */
+	ap1302->i2csel_gpio = devm_gpiod_get_optional(ap1302->dev, "i2csel",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->i2csel_gpio))
+	{
+		dev_err( ap1302->dev, "Can't get i2csel GPIO: %ld\n",
+			PTR_ERR(ap1302->i2csel_gpio));
+	}
+	else
+		gpiod_set_value(ap1302->i2csel_gpio, 1);
+
+	/* ISP Trigger Pin */
+	ap1302->isptrig_gpio = devm_gpiod_get_optional(ap1302->dev, "isptrig",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->isptrig_gpio))
+	{
+		dev_err( ap1302->dev, "Can't get isptrig GPIO: %ld\n",
+			PTR_ERR(ap1302->isptrig_gpio));
+	}
+	else
+		gpiod_set_value(ap1302->isptrig_gpio, 1);
 
 	/* Bus configuration */
 	ep = fwnode_graph_get_next_endpoint(dev_fwnode(ap1302->dev), NULL);
@@ -2812,9 +2897,8 @@ static void ap1302_cleanup(struct ap1302_device *ap1302)
 static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct ap1302_device *ap1302;
-	unsigned int i;
 	int ret;
-
+	const struct ap1302_sensor_info *info=NULL;
 	ap1302 = devm_kzalloc(&client->dev, sizeof(*ap1302), GFP_KERNEL);
 	if (!ap1302)
 		return -ENOMEM;
@@ -2844,16 +2928,9 @@ static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *i
 	if (ret < 0)
 		goto error;
 
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		if (!sensor->ap1302)
-			continue;
-
-		ret = ap1302_sensor_init(sensor, i);
-		if (ret < 0)
-			goto error;
-	}
+	info = ap1302->sensor_info;
+	ap1302->frame_interval.numerator = 1;
+	ap1302->frame_interval.denominator = info->fps;
 
 	ret = ap1302_hw_init(ap1302);
 	if (ret)
@@ -2865,6 +2942,7 @@ static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *i
 	if (ret)
 		goto error_hw_cleanup;
 
+	dev_info(ap1302->dev,"ap1302 driver probed successfully \n");
 	return 0;
 
 error_hw_cleanup:
-- 
2.17.1

